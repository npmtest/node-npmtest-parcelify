{"/home/travis/build/npmtest/node-npmtest-parcelify/test.js":"/* istanbul instrument in package npmtest_parcelify */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-parcelify/lib.npmtest_parcelify.js":"/* istanbul instrument in package npmtest_parcelify */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_parcelify = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_parcelify = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-parcelify/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-parcelify && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_parcelify */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_parcelify\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_parcelify.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_parcelify.rollup.js'] =\n            local.assetsDict['/assets.npmtest_parcelify.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_parcelify.__dirname + '/lib.npmtest_parcelify.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-parcelify/node_modules/parcelify/index.js":"var path = require('path');\nvar parcelMap = require( 'parcel-map' );\nvar shasum = require( 'shasum' );\nvar through2 = require( 'through2' );\nvar path = require( 'path' );\nvar _ = require( 'underscore' );\nvar async = require( 'async' );\nvar glob = require( 'glob' );\nvar Package = require( './lib/package' );\nvar Parcel = require( './lib/parcel' );\nvar inherits = require( 'inherits' );\nvar log = require( 'npmlog' );\n\nvar EventEmitter = require('events').EventEmitter;\nvar Package = require('./lib/package.js');\n\nmodule.exports = Parcelify;\n\ninherits( Parcelify, EventEmitter );\n\nfunction Parcelify( browserifyInstance, options ) {\n\tvar _this = this;\n\t\n\tif( ! ( this instanceof Parcelify ) ) return new Parcelify( browserifyInstance, options );\n\n\toptions = _.defaults( {}, options, {\n\t\tbundles : {},\t\t\t\t\t\t// ignored when bundlesByEntryPoint is provided\n\t\tbundlesByEntryPoint : undefined,\t// required when there are multiple entry points\n\n\t\tappTransforms : undefined,\n\t\tappTransformDirs : undefined,\n\t\t\n\t\twatch : undefined,\n\t\tlogLevel : undefined,\n\n\t\t// used internally or in order to share packages between multiple parcelify instances\n\t\texistingPackages : undefined\n\t} );\n\n\t// option aliases\n\tif( _.isUndefined( options.bundles.style ) ) options.bundles.style = options.o || 'bundle.css';\n\tif( _.isUndefined( options.appTransforms ) ) options.appTransforms = options.t || [];\n\tif( _.isUndefined( options.appTransformDirs ) ) options.appTransformDirs = options.d || [];\n\tif( _.isUndefined( options.watch ) ) options.watch = options.w || false;\n\tif( _.isUndefined( options.logLevel ) ) options.logLevel = options.l;\n\n\tif( _.isString( options.appTransforms ) ) options.appTransforms = [ options.appTransforms ];\n\n\tthis.watching = false;\n\n\tif( options.logLevel ) log.level = options.logLevel;\n\n\t// before we jump the gun, return from this function so we can listen to events from the calling function\n\tprocess.nextTick( function() {\n\t\tvar existingPackages = options.existingPackages || {};\n\t\tvar mappedAssets = {};\n\n\t\t_this.on( 'error', function( err ) {\n\t\t\tlog.error( '', err ); // otherwise errors kill our watch task. Especially bad for transform errors\n\t\t} );\n\n\t\tif( options.watch ) {\n\t\t\tbrowserifyInstance.on( 'update', _.debounce( function( changedMains ) {\n\t\t\t\t_this.watching = true;\n\n\t\t\t\tvar processParcelOptions = _.clone( options );\n\t\t\t\tprocessParcelOptions.existingPackages = existingPackages;\n\t\t\t\tprocessParcelOptions.mappedAssets = mappedAssets;\n\n\t\t\t\t_this.processParcels( browserifyInstance, processParcelOptions, function( err ) {\n\t\t\t\t\tif( err ) _this.emit( 'error', err );\n\t\t\t\t} );\n\t\t\t}, 1000, true ) );\n\t\t}\n\n\t\tvar processParcelOptions = _.clone( options );\n\t\tprocessParcelOptions.existingPackages = existingPackages;\n\t\tprocessParcelOptions.mappedAssets = mappedAssets;\n\n\t\t_this.processParcels( browserifyInstance, processParcelOptions, function( err ) {\n\t\t\tif( err ) _this.emit( 'error', err );\n\t\t} );\n\t} );\n\n\treturn _this;\n}\n\nParcelify.prototype.processParcels = function( browserifyInstance, options, callback ) {\n\tvar _this = this;\n\n\tvar existingPackages = options.existingPackages || {};\n\tvar assetTypes;\n\n\tif( options.bundlesByEntryPoint ) {\n\t\tassetTypes = _.reduce( options.bundlesByEntryPoint, function( assetTypesMemo, bundlesForThisEntryPoint ) {\n\t\t\treturn _.union( assetTypesMemo, _.keys( bundlesForThisEntryPoint ) );\n\t\t}, [] )\n\t} else assetTypes = _.keys( options.bundles );\n\t\n\tvar packages = _.reduce( existingPackages, function( memo, thisPackage, thisPackageId ) {\n\t\tmemo[ thisPackage.path ] = thisPackage.package;\n\t\treturn memo;\n\t}, {} );\n\n\tvar dependencies = _.reduce( existingPackages, function( memo, thisPackage, thisPackageId ) {\n\t\tmemo[ thisPackage.path ] = _.map( thisPackage.dependencies, function( thisDependency ) { return thisDependency.path; } );\n\t\treturn memo;\n\t}, {} );\n\n\tvar parcelMapEmitter = parcelMap( browserifyInstance, {\n\t\tkeys : assetTypes,\n\t\tfiles : options.mappedAssets,\n\t\tpackages : packages,\n\t\tdependencies : dependencies\n\t} );\n\n\tparcelMapEmitter.on( 'error', function( err ) {\n\t\treturn callback( err );\n\t} );\n\n\tparcelMapEmitter.on( 'done', function( parcelMapResult ) {\n\t\t_this.instantiateParcelAndPackagesFromMap( parcelMapResult, existingPackages, assetTypes, options.appTransforms, options.appTransformDirs, function( err, packagesThatWereCreated ) {\n\t\t\tif( err ) return callback( err );\n\n\t\t\tvar parcelsThatWereCreated = [];\n\n\t\t\tprocess.nextTick( function() {\n\t\t\t\tasync.series( [ function( nextSeries ) {\n\t\t\t\t\t// fire package events for any new packages\n\t\t\t\t\t_.each( packagesThatWereCreated, function( thisPackage ) {\n\t\t\t\t\t\tvar isParcel = thisPackage.isParcel;\n\n\t\t\t\t\t\tlog.verbose( 'Created new ' + ( isParcel ? 'parcel' : 'package' ) + ' ' + thisPackage.path + ' with id ' + thisPackage.id );\n\n\t\t\t\t\t\texistingPackages[ thisPackage.id ] = thisPackage;\n\t\t\t\t\t\tif( isParcel ) {\n\t\t\t\t\t\t\t_this._setupParcelEventRelays( thisPackage );\n\t\t\t\t\t\t\tparcelsThatWereCreated.push( thisPackage );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthisPackage.on( 'error', function( err ) {\n\t\t\t\t\t\t\t_this.emit( 'error', err );\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t_this.emit( 'packageCreated', thisPackage );\n\t\t\t\t\t} );\n\n\t\t\t\t\tnextSeries();\n\t\t\t\t}, function( nextSeries ) {\n\t\t\t\t\tif( parcelsThatWereCreated.length > 1 && ! options.bundlesByEntryPoint ) {\n\t\t\t\t\t\treturn nextSeries( new Error( 'Multiple entry points detected, but bundlesByEntryPoint option was not supplied.' ) );\n\t\t\t\t\t}\n\n\t\t\t\t\tif( parcelsThatWereCreated.length === 1 && ! options.bundlesByEntryPoint ) {\n\t\t\t\t\t\toptions.bundlesByEntryPoint = {};\n\t\t\t\t\t\toptions.bundlesByEntryPoint[ _.first( parcelsThatWereCreated ).mainPath ] = options.bundles;\n\t\t\t\t\t}\n\n\t\t\t\t\t// we are done copying packages and collecting our asset streams. Now write our bundles to disk.\n\t\t\t\t\tasync.each( _.values( packagesThatWereCreated ), function( thisParcel, nextEach ) {\n\t\t\t\t\t\tif( ! thisParcel.isParcel ) return nextEach();\n\n\t\t\t\t\t\tvar thisParcelBundles = options.bundlesByEntryPoint[ thisParcel.mainPath ];\n\t\t\t\t\t\n\t\t\t\t\t\tasync.each( Object.keys( thisParcelBundles ), function( thisAssetType, nextEach ) {\n\t\t\t\t\t\t\tvar thisBundlePath = thisParcelBundles[ thisAssetType ];\n\t\t\t\t\t\t\tif( ! thisBundlePath ) return nextEach();\n\n\t\t\t\t\t\t\tthisParcel.writeBundle( thisAssetType, thisBundlePath, function( err, bundleWasWritten ) {\n\t\t\t\t\t\t\t\t// don't stop writing other bundles if there was an error on this one. errors happen\n\t\t\t\t\t\t\t\t// frequently with transforms.. like invalid scss, etc. don't stop the show, just \n\t\t\t\t\t\t\t\t// keep going with our other bundles.\n\n\t\t\t\t\t\t\t\tif( err ) _this.emit( 'error', err );\n\t\t\t\t\t\t\t\telse if( bundleWasWritten ) _this.emit( 'bundleWritten', thisBundlePath, thisAssetType, thisParcel, _this.watching );\n\n\t\t\t\t\t\t\t\tnextEach();\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}, nextEach );\n\t\t\t\t\t}, nextSeries );\n\t\t\t\t}, function( nextSeries ) {\n\t\t\t\t\tif( options.watch ) {\n\t\t\t\t\t\t// we only create glob watchers for the packages that parcel added to the manifest. Again, we want to avoid doubling up\n\t\t\t\t\t\t// work in situations where we have multiple parcelify instances running that share common bundles\n\t\t\t\t\t\t_.each( packagesThatWereCreated, function( thisPackage ) {\n\t\t\t\t\t\t\tthisPackage.createWatchers( assetTypes, browserifyInstance._options.packageFilter, options.appTransforms, options.appTransformDirs );\n\t\t\t\t\t\t\tif( thisPackage.isParcel ) {\n\t\t\t\t\t\t\t\tthisPackage.attachWatchListeners( options.bundlesByEntryPoint[ thisPackage.mainPath ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\n\t\t\t\t\tif( ! _this.watching ) _this.emit( 'done' );\n\n\t\t\t\t\tnextSeries();\n\t\t\t\t} ], callback );\n\t\t\t} );\n\n\t\t\treturn callback( null );\n\t\t} );\n\t} );\n};\n\nParcelify.prototype.instantiateParcelAndPackagesFromMap = function( parcelMapResult, existingPacakages, assetTypes, appTransforms, appTransformDirs, callback ) {\n\tvar _this = this;\n\tvar mappedParcel = null;\n\tvar packagesThatWereCreated = {};\n\n\tasync.series( [ function( nextSeries ) {\n\t\tasync.each( Object.keys( parcelMapResult.packages ), function( thisPackageId, nextPackageId ) {\n\t\t\tvar packageJson = parcelMapResult.packages[ thisPackageId ];\n\t\t\tvar packageOptions = {};\n\n\t\t\tasync.waterfall( [ function( nextWaterfall ) {\n\t\t\t\tPackage.getOptionsFromPackageJson( thisPackageId, packageJson.__path, packageJson, assetTypes, appTransforms, appTransformDirs, nextWaterfall );\n\t\t\t}, function( packageOptions, nextWaterfall ) {\n\t\t\t\tvar thisPackage;\n\n\t\t\t\tvar thisPackageIsAParcel = packageJson.__isParcel;\n\n\t\t\t\tif( ! existingPacakages[ thisPackageId ] ) {\n\t\t\t\t\tif( thisPackageIsAParcel ) {\n\t\t\t\t\t\tthisPackage = packagesThatWereCreated[ thisPackageId ] = new Parcel( _.extend( packageOptions, { mainPath : packageJson.__mainPath } ) );\n\t\t\t\t\t}\n\t\t\t\t\telse thisPackage = packagesThatWereCreated[ thisPackageId ] = new Package( packageOptions );\n\n\t\t\t\t\tthisPackage.createAllAssets( assetTypes );\n\t\t\t\t}\n\t\t\t\telse if( thisPackageIsAParcel && ! existingPacakages[ thisPackageId ] instanceof Parcel ) {\n\t\t\t\t\t// k tricky here.. if this package is a parcel, but it exists in the manifest as a plain\n\t\t\t\t\t// old package, then we gotta recreate this package as a parcel. also we have to update\n\t\t\t\t\t// any parcels that are dependENTS of this package/parcel in order to use the new\n\t\t\t\t\t// assets that we are about to create. man, scary, hope nothing gets broke in the process.\n\t\t\t\t\t// we could also pre-preemptively list out which packages are parcels by adding an option\n\t\t\t\t\t// to parcelify itself, but that seems a little weird. In the context of cartero that\n\t\t\t\t\t// depends on the path of each package relative to the parcelDirs cartero option.\n\t\t\t\t\tvar oldPackage = existingPacakages[ thisPackageId ];\n\t\t\t\t\tvar oldDependentParcels = oldPackage.dependentParcels;\n\n\t\t\t\t\toldPackage.destroy();\n\n\t\t\t\t\tthisPackage = packagesThatWereCreated[ thisPackageId ] = new Parcel( packageOptions );\n\t\t\t\t\tthisPackage.createAllAssets( assetTypes );\n\n\t\t\t\t\toldDependentParcels.forEach( function( thisDependentParcel ) {\n\t\t\t\t\t\tthisPackage.addDependentParcel( thisDependentParcel );\n\t\t\t\t\t\tthisDependentParcel.calcSortedDependencies();\n\t\t\t\t\t\tthisDependentParcel.calcParcelAssets( assetTypes );\n\t\t\t\t\t} );\n\n\t\t\t\t\tlog.warn( '', 'Recreated package at ' + thisPackage.path + ' as Parcel.' );\n\t\t\t\t} else\n\t\t\t\t\tthisPackage = existingPacakages[ thisPackageId ];\n\n\t\t\t\tnextWaterfall();\n\t\t\t} ], nextPackageId );\n\t\t}, nextSeries );\n\t}, function( nextSeries ) {\n\t\tvar allPackages = _.extend( {}, existingPacakages, packagesThatWereCreated );\n\n\t\t// now that we have all our packages instantiated, hook up dependencies\n\t\t_.each( parcelMapResult.dependencies, function( dependencyIds, thisPackageId ) {\n\t\t\tvar thisPackage = allPackages[ thisPackageId ];\n\n\t\t\tif( ! thisPackage ) return nextSeries( new Error( 'Unknown package id in dependency ' + thisPackageId ) );\n\n\t\t\tvar thisPackageDependencies = _.map( dependencyIds, function( thisDependencyId ) { return allPackages[ thisDependencyId ]; } );\n\t\t\tthisPackage.setDependencies( thisPackageDependencies );\n\t\t} );\n\n\t\t// finally, we can calculate the topo sort of any parcels that were created\n\t\t_.each( packagesThatWereCreated, function( thisParcel ) {\n\t\t\tif( thisParcel.isParcel ) {\n\t\t\t\tthisParcel.calcSortedDependencies();\n\t\t\t\tthisParcel.calcParcelAssets( assetTypes );\n\n\t\t\t\t_.each( thisParcel.sortedDependencies, function( thisDependentPackage ) {\n\t\t\t\t\tthisDependentPackage.addDependentParcel( thisParcel );\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\tnextSeries();\n\t} ], function( err ) {\n\t\treturn callback( err, packagesThatWereCreated );\n\t} );\n};\n\nParcelify.prototype._setupParcelEventRelays = function( parcel ) {\n\tvar _this = this;\n\tvar eventsToRelay = [ 'assetUpdated', 'packageJsonUpdated' ];\n\n\teventsToRelay.forEach( function( thisEvent ) {\n\t\tparcel.on( thisEvent, function() {\n\t\t\tvar args = Array.prototype.slice.call( arguments );\n\t\t\t_this.emit.apply( _this, [].concat( thisEvent, args ) );\n\t\t} );\n\t} );\n\n\tparcel.on( 'bundleUpdated', function( bundlePath, assetType ) {\n\t\t_this.emit( 'bundleWritten', bundlePath, assetType, parcel, true );\n\t} );\n};","/home/travis/build/npmtest/node-npmtest-parcelify/node_modules/parcelify/lib/package.js":"var path = require('path');\nvar fs = require( 'fs' );\nvar inherits = require( 'inherits' );\nvar EventEmitter = require( 'events' ).EventEmitter;\nvar _ = require( 'underscore' );\nvar async = require( 'async' );\nvar glob = require( 'glob' );\nvar globwatcher = require( 'globwatcher' ).globwatcher;\nvar Asset = require( './asset' );\nvar resolve = require( 'resolve' );\nvar log = require( 'npmlog' );\n\nmodule.exports = Package;\n\ninherits( Package, EventEmitter );\n\nfunction Package( options ) {\n\n\t_.extend( this, _.pick( options,\n\t\t'id',\n\t\t'package',\n\t\t'path',\n\t\t'dependencies',\n\t\t'assetSrcPathsByType',\n\t\t'assetGlobsByType',\n\t\t'assetTransformsByType'\n\t) );\n\n\tthis.dependencies = [];\n\tthis.dependentParcels = [];\n\tthis.assetsByType = {};\n\n\tEventEmitter.call( this );\n}\n\nPackage.prototype.createAllAssets = function( assetTypes ) {\n\tvar _this = this;\n\n\t_this.assetsByType = {};\n\tassetTypes.forEach( function( thisAssetType ) { _this.assetsByType[ thisAssetType ] = []; } );\n\n\tObject.keys( this.assetSrcPathsByType ).forEach( function( assetType ) {\n\t\t_this.assetSrcPathsByType[ assetType ].forEach( function( thisAssetSrcPath ) {\n\t\t\tvar thisAsset = _this.createAsset( thisAssetSrcPath, assetType );\n\t\t} );\n\t} );\n};\n\nPackage.prototype.createAsset = function( thisAssetSrcPath, assetType, appData ) {\n\tvar thisAsset = new Asset( thisAssetSrcPath, assetType, _.clone( this.assetTransformsByType[ assetType ] ), appData );\n\n\tlog.verbose( '', assetType + ' asset registered \"%s\"', path.relative( process.cwd(), thisAssetSrcPath ) );\n\n\tif( ! this.assetsByType[ assetType ] ) this.assetsByType[ assetType ] = [];\n\tthis.assetsByType[ assetType ].push( thisAsset );\n\n\treturn thisAsset;\n};\n\nPackage.prototype.getAssets = function( types ) {\n\treturn _.reduce( this.assetsByType, function( memo, assetsOfThisType, thisAssetType ) {\n\t\tif( types && ! _.contains( types, thisAssetType ) ) return memo;\n\n\t\treturn memo.concat( assetsOfThisType );\n\t}, [] );\n};\n\nPackage.prototype.addTransform = function( transform, transformOptions, toAssetTypes, prepend ) {\n\tif( _.isUndefined( prepend ) ) prepend = false;\n\n\tvar t = transformOptions ? function( file ) { return transform( file, transformOptions ); } : transform;\n\n\ttoAssetTypes = toAssetTypes || Object.keys( this.assetsByType );\n\tif( ! _.isArray( toAssetTypes ) ) toAssetTypes = [ toAssetTypes ];\n\n\t// add transform to existing assets\n\tthis.getAssets( toAssetTypes ).forEach( function( thisAsset ) {\n\t\tthisAsset.addTransform( t, prepend );\n\t} );\n\n\t// and also add it to the package itself so it is added to assets created from this point forward\n\t_.each( _.pick( this.assetTransformsByType, toAssetTypes ), function( transformsForThisAssetType ) {\n\t\tif( prepend ) transformsForThisAssetType.unshift( t );\n\t\telse transformsForThisAssetType.push( t );\n\t} );\n};\n\nPackage.prototype.setDependencies = function( dependencies ) {\n\tthis.dependencies = dependencies;\n};\n\nPackage.prototype.addDependentParcel = function( parcel ) {\n\tthis.dependentParcels = _.union( this.dependentParcels, parcel );\n};\n\nPackage.prototype.createWatchers = function( assetTypes, packageFilter, appTransforms, appTransformDirs ) {\n\tthis._createPackageJsonWatcher( assetTypes, packageFilter, appTransforms, appTransformDirs );\n\tthis._createAssetGlobWatchers();\n};\n\nPackage.prototype.destroy = function() {\n\tthis._destroyAssetGlobWatchers();\n\tthis.assetJsonWatcher.close();\n};\n\n/********************* Private instance methods *********************/\n\nPackage.prototype._createPackageJsonWatcher = function( assetTypes, packageFilter, appTransforms, appTransformDirs ) {\n\tvar _this = this;\n\n\tthis.assetJsonWatcher = globwatcher( path.resolve( this.path, \"package.json\" ) );\n\tthis.assetJsonWatcher.on( 'changed', function( srcPath ) {\n\t\tlog.info( 'watch', 'package.json changed \"%s\"', path.relative( process.cwd(), srcPath ) );\n\n\t\tfs.readFile( srcPath, 'utf8', function( err, packageJson ) {\n\t\t\tif( err ) return _this.emit( 'error', err );\n\n\t\t\ttry {\n\t\t\t\tpackageJson = JSON.parse( packageJson );\n\t\t\t} catch( err ) {\n\t\t\t\treturn _this.emit( 'error', new Error( 'While parsing \"' + srcPath + '\", ' + err ) );\n\t\t\t}\n\n\t\t\tpackageJson.__path = _this.path;\n\n\t\t\tif( packageFilter ) packageJson = packageFilter( packageJson, _this.path );\n\n\t\t\tPackage.getOptionsFromPackageJson( _this.id, _this.path, packageJson, assetTypes, appTransforms, appTransformDirs, function( err, options ) {\n\t\t\t\tif( err ) return _this.emit( 'error', err );\n\n\t\t\t\t_.extend( _this, options );\n\n\t\t\t\t_this.createAllAssets( assetTypes );\n\n\t\t\t\t_this._destroyAssetGlobWatchers();\n\t\t\t\t_this._createAssetGlobWatchers();\n\n\t\t\t\t_this._emitEventOnRelevantParcels( 'packageJsonUpdated', _this );\n\t\t\t} );\n\t\t} );\n\t} );\n};\n\nPackage.prototype._createAssetGlobWatchers = function() {\n\tvar _this = this;\n\n\tthis.assetGlobWatchers = [];\n\n\t_.each( _this.assetGlobsByType, function( globs, thisAssetType ) {\n\t\tvar thisWatcher = globwatcher( globs );\n\n\t\tthisWatcher.on( 'changed', function( srcPath ) {\n\t\t\ttry {\n\t\t\t\tlog.info( 'watch', '\"%s\" changed', path.relative( process.cwd(), srcPath ) );\n\n\t\t\t\tvar asset = _.findWhere( _this.assetsByType[ thisAssetType ], { srcPath : srcPath } );\n\t\t\t\tif( ! asset ) return _this.emit( 'error', new Error( 'Couldn\\'t find changed file ' + srcPath + ' in assets of type ' + thisAssetType ) );\n\n\t\t\t\t_this._emitEventOnRelevantParcels( 'assetUpdated', 'changed', asset, _this );\n\t\t\t} catch( err ) {\n\t\t\t\treturn _this.emit( 'error', err );\n\t\t\t}\n\t\t} );\n\n\t\tthisWatcher.on( 'added', function( srcPath ) {\n\t\t\ttry {\n\t\t\t\tlog.info( 'watch', '\"%s\" added', path.relative( process.cwd(), srcPath ) );\n\t\t\t\n\t\t\t\tvar asset = _.findWhere( _this.assetsByType[ thisAssetType ], { srcPath : srcPath } );\n\t\t\t\t// watching is weird... sometimes we get double events. make sure we don't add the same asset twice.\n\t\t\t\tif( asset ) return _this.emit( 'error', new Error( 'Asset ' + srcPath + ' already exists in assets of type ' + thisAssetType ) );\n\t\t\t\t\n\t\t\t\tasset = _this.createAsset( srcPath, thisAssetType );\n\n\t\t\t\t_this._emitEventOnRelevantParcels( 'assetUpdated', 'added', asset, _this );\n\t\t\t} catch( err ) {\n\t\t\t\treturn _this.emit( 'error', err );\n\t\t\t}\n\t\t} );\n\n\t\tthisWatcher.on( 'deleted', function( srcPath ) {\n\t\t\ttry {\n\t\t\t\tlog.info( 'watch', '\"%s\" deleted', path.relative( process.cwd(), srcPath ) );\n\n\t\t\t\tvar asset = _.findWhere( _this.assetsByType[ thisAssetType ], { srcPath : srcPath } );\n\t\t\t\tif( ! asset ) return _this.emit( 'error', new Error( 'Couldn\\'t find changed file ' + srcPath + ' in assets of type ' + thisAssetType ) );\n\n\t\t\t\t_this.assetsByType[ thisAssetType ] = _.without( _this.assetsByType[ thisAssetType ], asset );\n\t\t\t\n\t\t\t\t_this._emitEventOnRelevantParcels( 'assetUpdated', 'deleted', asset, _this );\n\t\t\t} catch( err ) {\n\t\t\t\treturn _this.emit( 'error', err );\n\t\t\t}\n\t\t} );\n\n\t\t_this.assetGlobWatchers.push( thisWatcher );\n\t} );\n};\n\nPackage.prototype._destroyAssetGlobWatchers = function() {\n\tthis.assetGlobWatchers.forEach( function( thisAssetGlobWatcher ) {\n\t\tthisAssetGlobWatcher.close();\n\t} );\n\n\tthis.assetGlobWatchers = [];\n};\n\nPackage.prototype._emitEventOnRelevantParcels = function() {\n\tvar args = Array.prototype.slice.call( arguments );\n\n\tthis.dependentParcels.forEach( function( thisParcel ) {\n\t\tthisParcel.emit.apply( thisParcel, args );\n\t} );\n};\n\n/********************* Static class methods *********************/\n\nPackage.getOptionsFromPackageJson = function( packageId, packagePath, packageJson, assetTypes, appTransforms, appTransformDirs, callback ) {\n\tvar packageOptions = {};\n\n\tif( appTransforms ) {\n\t\tvar pkgIsInAppTransformsDir = _.find( appTransformDirs, function( thisAppDirPath ) {\n\t\t\tvar relPath = path.relative( thisAppDirPath, packagePath );\n\t\t\tvar needToBackup = relPath.charAt( 0 ) === '.' && relPath.charAt( 1 ) === '.';\n\t\t\tvar appTransformsApplyToThisDir = ! needToBackup && relPath.indexOf( 'node_modules' ) === -1;\n\t\t\treturn appTransformsApplyToThisDir;\n\t\t} );\n\n\t\tif( pkgIsInAppTransformsDir )\n\t\t\tpackageJson.transforms = appTransforms.concat( packageJson.transforms || [] );\n\t}\n\n\tpackageOptions.package = packageJson;\n\tpackageOptions.id = packageId;\n\tpackageOptions.path = packagePath;\n\n\tpackageOptions.assetSrcPathsByType = {};\n\tpackageOptions.assetTransformsByType = {};\n\tpackageOptions.assetGlobsByType = {};\n\n\tasync.each( assetTypes, function( thisAssetType, nextAssetType ) {\n\n\t\tasync.parallel( [ function( nextParallel ) {\n\t\t\tpackageOptions.assetSrcPathsByType[ thisAssetType ] = [];\n\n\t\t\t// resolve relative globs to absolute globs\n\t\t\tvar relativeGlobsOfThisType = packageJson[ thisAssetType ] || [];\n\t\t\tif( _.isString( relativeGlobsOfThisType ) ) relativeGlobsOfThisType = [ relativeGlobsOfThisType ];\n\t\t\tvar absoluteGlobsOfThisType = relativeGlobsOfThisType.map( function( thisGlob ) { return path.resolve( packagePath, thisGlob ); } );\n\t\t\tpackageOptions.assetGlobsByType[ thisAssetType ] = absoluteGlobsOfThisType;\n\n\t\t\t// resolve absolute globs to actual src files\n\t\t\tasync.map( absoluteGlobsOfThisType, glob,\n\t\t\tfunction( err, arrayOfResolvedGlobs ) {\n\t\t\t\tif( err ) return nextParallel( err );\n\n\t\t\t\tvar assetsOfThisType = _.flatten( arrayOfResolvedGlobs );\n\t\t\t\tpackageOptions.assetSrcPathsByType[ thisAssetType ] = assetsOfThisType;\n\n\t\t\t\tnextParallel();\n\t\t\t} );\n\t\t}, function( nextParallel ) {\n\t\t\t// resolve transform names to actual transform\n\t\t\tpackageOptions.assetTransformsByType[ thisAssetType ] = [];\n\n\t\t\tif( packageJson.transforms ) {\n\t\t\t\tif( _.isArray( packageJson.transforms ) )\n\t\t\t\t\ttransformNames = packageJson.transforms;\n\t\t\t\telse\n\t\t\t\t\ttransformNames = packageJson.transforms[ thisAssetType ] || [];\n\t\t\t}\n\t\t\telse\n\t\t\t\ttransformNames = [];\n\n\t\t\tasync.map( transformNames, function( thisTransformName, nextTransform ) {\n\t\t\t\tif( _.isFunction( thisTransformName ) ) return nextTransform( null, thisTransformName );\n\n\t\t\t\tresolve( thisTransformName, { basedir : packageJson.__path }, function( err, modulePath ) {\n\t\t\t\t\tif( err ) return nextTransform( err );\n\n\t\t\t\t\tnextTransform( null, require( modulePath ) );\n\t\t\t\t} );\n\t\t\t}, function( err, transforms ) {\n\t\t\t\tif( err ) return nextParallel( err );\n\n\n\t\t\t\tpackageOptions.assetTransformsByType[ thisAssetType ] = transforms;\n\t\t\t\tnextParallel();\n\t\t\t} );\n\t\t} ], nextAssetType );\n\t}, function( err ) {\n\t\tif( err ) return callback( err );\n\n\t\tcallback( null, packageOptions );\n\t} );\n};\n","/home/travis/build/npmtest/node-npmtest-parcelify/node_modules/parcelify/lib/asset.js":"var fs = require( 'fs' );\nvar async = require( 'async' );\nvar mkdirp = require( 'mkdirp' );\nvar combine = require( 'stream-combiner' );\nvar path = require( 'path' );\nvar _ = require( 'underscore' );\n\nmodule.exports = Asset;\n\nfunction Asset( srcPath, type, transforms, appData ) {\n\tthis.srcPath = srcPath;\n\tthis.type = type;\n\tthis.transforms = transforms;\n\tthis.appData = appData;\n}\n\nAsset.prototype.addTransform = function( transform, prepend ) {\n\tif( _.isUndefined( prepend ) ) prepend = false;\n\n\tif( prepend ) this.transforms.unshift( transform );\n\telse this.transforms.push( transform );\n};\n\nAsset.prototype.createReadStream = function() {\n\tvar stream = fs.createReadStream( this.srcPath );\n\treturn this._applyTransforms( stream, this.transforms );\n};\n\nAsset.prototype.writeToDisk = function( dstPath, callback ) {\n\tvar _this = this;\n\n\tthis.dstPath = dstPath; // save this for later\n\n\tasync.series( [ function( nextSeries ) {\n\t\tmkdirp( path.dirname( dstPath ), nextSeries );\n\t}, function( nextSeries ) {\n\t\tvar stream = _this.createReadStream();\n\t\tstream.on( 'error', function( err ) {\n\t\t\tnextSeries( new Error( 'While reading or transforming \"' + _this.srcPath + '\":\\n' + err.message ) );\n\t\t} );\n\t\tstream.on( 'end', nextSeries );\n\t\tstream.pipe( fs.createWriteStream( dstPath ) );\n\t} ], callback );\n};\n\nAsset.prototype._applyTransforms = function( stream, transforms ) {\n\tvar _this = this;\n\n\tif( ! transforms || transforms.length === 0 ) return stream;\n\t\n\tvar combinedStream = combine.apply( null, transforms.map( function( thisTransform ) {\n\t\treturn thisTransform( _this.srcPath );\n\t} ) );\n\n\treturn stream.pipe( combinedStream );\n};\n","/home/travis/build/npmtest/node-npmtest-parcelify/node_modules/parcelify/lib/parcel.js":"var inherits = require( 'inherits' );\nvar Package = require( './package' );\nvar _ = require( 'underscore' );\nvar async = require( 'async' );\nvar toposort = require( 'toposort' );\nvar through2 = require( 'through2' );\nvar path = require( 'path' );\nvar crypto = require( 'crypto' );\nvar fs = require( 'fs' );\n\nmodule.exports = Parcel;\n\ninherits( Parcel, Package );\n\nfunction Parcel( options ) {\n\tvar _this = this;\n\n\tPackage.call( this, options );\n\n\tthis.mainPath = options.mainPath;\n\tthis.isParcel = true;\n\tthis.bundlePathsByType = {};\n\tthis.parcelAssetsByType = {};\n\n\tthis.dependentParcels.push( this ); // parcels depend on themselves!\n}\n\nParcel.prototype.calcSortedDependencies = function() {\n\tvar packagesWithDependencies = [];\n\n\tfunction getEdgesForPackageDependencyGraph( thisPackage, thisTreeLevel, packageTreeLevels ) {\n\t\tif( _.isUndefined( thisTreeLevel ) ) thisTreeLevel = 0;\n\t\tif( _.isUndefined( packageTreeLevels ) ) packageTreeLevels = {};\n\n\t\tif( ! packageTreeLevels[ thisPackage.path ] ) packageTreeLevels[ thisPackage.path ] = thisTreeLevel;\n\n\t\treturn thisPackage.dependencies.reduce( function( memo, thisDependentPackage ) {\n\t\t\t// these conditionals are to avoid cycles and infinite recursion.\n\t\t\t// first, we only traverse each node once to avoid infinite recursion.\n\t\t\tif( _.isUndefined( packageTreeLevels[ thisDependentPackage.path ] ) ) {\n\t\t\t\tmemo = memo.concat( getEdgesForPackageDependencyGraph( thisDependentPackage, thisTreeLevel + 1, packageTreeLevels ) );\n\t\t\t}\n\n\t\t\t// second, we keep track of the levels of the nodes in the dependency tree (where\n\t\t\t// level 0 is the root node i.e. the parcel itself). nodes can only have dependencies\n\t\t\t// on other nodes with a level equal to or greater than their own. done.\n\t\t\tif( packageTreeLevels[ thisDependentPackage.path ] >= packageTreeLevels[ thisPackage.path ] ) {\n\t\t\t\tmemo = memo.concat( [ [ thisPackage, thisDependentPackage ] ] );\n\t\t\t}\n\n\t\t\treturn memo;\n\t\t}, [] );\n\t}\n\n\tvar edges = getEdgesForPackageDependencyGraph( this );\n\tvar sortedPackages = toposort( edges ).reverse();\n\n\t//sortedPackages = _.union( sortedPackages, Object.keys( packageManifest ) ); // union cuz some packages have no dependencies!\n\tsortedPackages = _.without( sortedPackages, this );\n\n\tthis.sortedDependencies = sortedPackages;\n};\n\nParcel.prototype.calcParcelAssets = function( assetTypes ) {\n\tmemo = {};\n\tassetTypes.forEach( function( thisAssetType ) { memo[ thisAssetType ] = []; } );\n\n\tvar sortedAssets = this.sortedDependencies.concat( this ).reduce( function( memo, thisPackage ) {\n\t\tvar thisPackageAssets = thisPackage.assetsByType;\n\n\t\t_.each( thisPackageAssets, function( assets, thisAssetType ) {\n\t\t\tif( _.contains( assetTypes, thisAssetType ) )\n\t\t\t\tmemo[ thisAssetType ] = memo[ thisAssetType ].concat( assets );\n\t\t} );\n\n\t\treturn memo;\n\t}, memo );\n\n\tthis.parcelAssetsByType = _.extend( {}, this.parcelAssetsByType, sortedAssets );\n};\n\nParcel.prototype.attachWatchListeners = function( bundles ) {\n\tvar _this = this;\n\n\tthis.on( 'assetUpdated', function( eventType, asset ) {\n\t\tif( _.contains( [ 'added', 'deleted' ], eventType ) )\n\t\t\tthis.calcParcelAssets( [ asset.type ] );\n\n\t\tif( bundles[ asset.type ] ) {\n\t\t\t_this.writeBundle( asset.type, bundles[ asset.type ], function( err, bundleWasWritten ) {\n\t\t\t\tif( err ) return _this.emit( 'error', err );\n\n\t\t\t\tif( bundleWasWritten ) _this.emit( 'bundleUpdated', bundles[ asset.type ], asset.type );\n\t\t\t\t// ... done!\n\t\t\t} );\n\t\t}\n\t} );\n\n\tthis.on( 'packageJsonUpdated', function( thePackage ) {\n\t\tvar bundlesToRewrite = _.pick( bundles, _.without( Object.keys( bundles ), 'script' ) );\n\t\tthis.calcParcelAssets( Object.keys( bundlesToRewrite ) );\n\n\t\tasync.each( Object.keys( bundlesToRewrite ), function( thisAssetType, nextEach ) {\n\t\t\tvar thisBundlePath = bundlesToRewrite[ thisAssetType ];\n\t\t\tif( ! thisBundlePath ) return nextEach();\n\t\t\n\t\t\t_this.writeBundle( thisAssetType, thisBundlePath, function( err, bundleWasWritten ) {\n\t\t\t\t// don't stop writing other bundles if there was an error on this one. errors happen\n\t\t\t\t// frequently with transforms.. like invalid scss, etc. don't stop the show, just \n\t\t\t\t// keep going with our other bundles.\n\n\t\t\t\tif( err ) _this.emit( 'error', err );\n\t\t\t\telse if( bundleWasWritten ) _this.emit( 'bundleWritten', thisBundlePath, thisAssetType, true );\n\n\t\t\t\tnextEach();\n\t\t\t} );\n\t\t}, function( err ) {\n\t\t\tif( err ) _this.emit( 'error', err );\n\n\t\t\t // done );\n\t\t} );\n\t} );\n};\n\nParcel.prototype.writeBundle = function( assetType, dstPath, callback ) {\n\tvar _this = this;\n\t\t\n\tvar srcAssets = _this.parcelAssetsByType[ assetType ];\n\tif( ! srcAssets || srcAssets.length === 0 ) return callback( null, false ); // we don't want to create an empty bundle just because we have no source files\n\n\tvar bundle = through2();\n\tvar tempBundlePath = path.join( path.dirname( dstPath ), '.temp_' + path.basename( dstPath ) );\n\n\tbundle.pipe( fs.createWriteStream( dstPath ) ).on( 'close', function ( err ) {\n\t\t// execution resumes here after all the individual asset streams\n\t\t// have been piped to this bundle. we need to pipe the bundle to the writable\n\t\t// stream first (before individual assets are piped to bundle stream)\n\t\t// so that if the high water mark is reached on one of the readable streams\n\t\t// it doesn't pause (with no way to resume). See github issue #15.\n\t\t\n\t\tif( err ) return callback( err, false );\n\n\t\t// fs.rename( tempBundlePath, dstPath, function( err ) {\n\t\t// \tif( err ) console.log( 'yoyoyoo', fs.existsSync( tempBundlePath ), dstPath, srcAssets );\n\n\t\t// \tif( err ) return callback( err );\n\n\t\t\t//_this.bundlePathsByType[ assetType ] = dstPath; // don't do this. isn't really a property of the parcel so much as an input to parcelify\n\n\t\t\tcallback( null, true );\n\t\t// } );\n\t} );\n\n\t// pipe all our individual style streams to the bundle in order to concatenate them\n\tasync.eachSeries( srcAssets, function( thisAsset, nextAsset ) {\n\t\tvar thisAssetStream = thisAsset.createReadStream();\n\n\t\tthisAssetStream.on( 'error', function( err ) {\n\t\t\tnextAsset( new Error( 'While reading or transforming \"' + thisAsset.srcPath + '\":\\n' + err.message ) );\n\t\t} );\n\n\t\tthisAssetStream.on( 'end', function( err ) {\n\t\t\tnextAsset();\n\t\t} );\n\n\t\tthisAssetStream.pipe( bundle, { end : false } );\n\t}, function( err ) {\n\t\tif( err ) return callback( err, false );\n\n\t\tbundle.end();\n\t\t\n\t\t// execution will resume up above on the\n\t\t// `close` event handler for our bundle\n\t} );\n};\n\n","/home/travis/build/npmtest/node-npmtest-parcelify/node_modules/parcelify/bin/cmd.js":"#!/usr/bin/env node\n\nvar parcelify = require( '../' );\nvar browserify = require( 'browserify' );\nvar watchify = require( 'watchify' );\nvar minimist = require( 'minimist' );\nvar path = require( 'path' );\nvar fs = require( 'fs' );\nvar os = require( 'os' );\nvar tmpdir = ( os.tmpdir || os.tmpDir )();\n\nvar argv = minimist( process.argv.slice(2),\n\t{\n\t\talias : {\n\t\t\tjsBundle : 'j',\n\t\t\tcssBundle : 'c',\n\t\t\ttransform : 't',\n\t\t\ttransformDirs : 'd',\n\t\t\twatch : 'w',\n\t\t\tmaps : 'm',\n\t\t\thelp : 'h'\n\t\t},\n\t\tboolean : [ 'watch', 'help', 'maps' ]\n\t}\n);\n\nif( argv.help ) {\n\treturn fs.createReadStream( __dirname + '/help.txt' ).pipe( process.stdout ).on( 'close', function() {\n\t\tprocess.exit( 0 );\n\t} );\n}\n\n// resolve to absolute paths\nvar jsBundle = resolvePath( argv.jsBundle ) || path.resolve( tmpdir, 'parcelify-js-bundle-' + Math.random() );\nvar cssBundle = resolvePath( argv.cssBundle );\nvar tmplBundle = resolvePath( argv.tmplBundle );\nvar mainPath = resolvePath( argv._[0] );\nvar appTransforms = argv.transform;\nvar appTransformDirs = argv.transformDirs;\nvar defaultTransforms = argv.transform;\nvar logLevel = argv.loglevel;\nvar watch = argv.watch;\nvar maps = argv.maps;\n\nif( typeof appTransformDirs === 'string' ) appTransformDirs = [ appTransformDirs ];\n\nif( ! mainPath ) {\n\tconsole.log( 'No entry point specified' );\n\tprocess.exit( 1 );\n}\n\nvar browserifyInstance = browserify( mainPath );\nif( watch ) watchify( browserifyInstance );\n\nvar p = parcelify( browserifyInstance, {\n\tbundles : {\n\t\tscript : jsBundle,\n\t\tstyle : cssBundle,\n\t\ttemplate : tmplBundle\n\t},\n\tappTransforms : appTransforms,\n\tappTransformDirs : appTransformDirs,\n\tbrowserifyBundleOptions : {\n\t\tdebug : maps\n\t},\n\twatch : watch,\n\tlogLevel : logLevel\n} );\n\nbrowserifyInstance.bundle().pipe( fs.createWriteStream( jsBundle ) );\n\np.on( 'error', function( err ) {\n\tconsole.log( err.stack );\n\tprocess.exit( 1 );\n} );\n\np.on( 'done', function() {\n\tif( ! watch )\n\t\tprocess.exit( 0 );\n} );\n\nfunction resolvePath( inputPath ) {\n\treturn inputPath ? path.resolve( inputPath ) : inputPath;\n}\n"}